<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khám phá Nghiệm Phức</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #f8fafc;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .tab-btn {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-btn.active {
            border-bottom-color: #4f46e5;
            color: #4f46e5;
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center h-screen">
    <div class="w-full h-full p-4 flex flex-col md:flex-row gap-4">
        <div class="flex-grow bg-white rounded-xl shadow-lg overflow-hidden">
            <canvas id="complexPlane"></canvas>
        </div>
        <div class="w-full md:w-96 bg-white rounded-xl shadow-lg p-6 flex-shrink-0 flex flex-col">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h1 class="text-xl font-bold text-gray-800">Bảng điều khiển</h1>
                <button id="download-btn" title="Tải tệp HTML" class="p-2 bg-slate-100 hover:bg-slate-200 rounded-lg transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="text-slate-600" viewBox="0 0 16 16">
                        <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                        <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                    </svg>
                </button>
            </div>
            
            <!-- Tabs -->
            <div class="flex border-b mb-4">
                <button class="tab-btn active" data-tab="root-form">Dạng Căn</button>
                <button class="tab-btn" data-tab="poly-form">Dạng Đa thức</button>
            </div>

            <!-- Equation Input Section -->
            <div id="root-form" class="tab-content active space-y-4 text-sm mb-4">
                <p class="font-semibold text-gray-700">Phương trình: (z - c)ⁿ = w</p>
                <div class="flex items-center gap-2">
                    <span class="font-mono text-lg">(z - (</span>
                    <input type="number" id="c_real" value="0" class="w-12 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">+</span>
                    <input type="number" id="c_imag" value="1" class="w-12 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">i))</span>
                    <span class="font-mono text-lg relative bottom-2">^</span>
                    <input type="number" id="n_power" value="4" min="2" max="20" class="w-12 text-center border rounded-md p-1 font-mono">
                </div>
                <div class="flex items-center gap-2">
                    <span class="font-mono text-lg">=</span>
                    <input type="number" id="w_real" value="1" class="w-16 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">+</span>
                    <input type="number" id="w_imag" value="1.732" step="0.001" class="w-16 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">i</span>
                </div>
            </div>
            <div id="poly-form" class="tab-content space-y-2 text-sm mb-4">
                 <p class="font-semibold text-gray-700">Phương trình: az⁴+bz³+cz²+dz+e = 0</p>
                 <div class="grid grid-cols-2 gap-2 items-center">
                    <label class="font-mono" for="poly_a">a (z⁴):</label><input type="text" id="poly_a" value="1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_b">b (z³):</label><input type="text" id="poly_b" value="-1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_c">c (z²):</label><input type="text" id="poly_c" value="1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_d">d (z):</label><input type="text" id="poly_d" value="-1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_e">e:</label><input type="text" id="poly_e" value="1" class="border rounded-md p-1 font-mono">
                 </div>
            </div>

            <button id="redraw-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors mb-4">
                Giải & Vẽ
            </button>

             <!-- Info Display Section -->
            <div id="info-panel" class="space-y-3 text-sm border-t pt-4">
                 <!-- Info will be populated by JS -->
            </div>

            <!-- Gemini Features Section -->
            <div class="mt-auto pt-4 border-t">
                <h2 class="text-lg font-bold text-gray-800 mb-3">✨ Trợ lý Gemini</h2>
                <div class="space-y-2">
                    <button id="explain-plot-btn" class="w-full text-left bg-indigo-100 hover:bg-indigo-200 text-indigo-800 font-semibold py-2 px-4 rounded-lg transition-colors">
                        Cách biểu diễn nghiệm
                    </button>
                    <button id="explain-geometry-btn" class="w-full text-left bg-indigo-100 hover:bg-indigo-200 text-indigo-800 font-semibold py-2 px-4 rounded-lg transition-colors">
                        Giải thích ý nghĩa hình học
                    </button>
                </div>
                <div id="loader" class="hidden">
                    <div class="loader"></div>
                </div>
                <div id="gemini-output" class="mt-4 p-3 bg-slate-50 rounded-lg text-sm text-gray-700 max-h-40 overflow-y-auto hidden">
                    <!-- Gemini response will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel');
        const redrawBtn = document.getElementById('redraw-btn');
        const tabs = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        const downloadBtn = document.getElementById('download-btn');
        
        // Input fields
        const cRealInput = document.getElementById('c_real');
        const cImagInput = document.getElementById('c_imag');
        const nPowerInput = document.getElementById('n_power');
        const wRealInput = document.getElementById('w_real');
        const wImagInput = document.getElementById('w_imag');
        const polyInputs = {
            a: document.getElementById('poly_a'), b: document.getElementById('poly_b'),
            c: document.getElementById('poly_c'), d: document.getElementById('poly_d'),
            e: document.getElementById('poly_e')
        };

        // Gemini elements
        const explainPlotBtn = document.getElementById('explain-plot-btn');
        const explainGeometryBtn = document.getElementById('explain-geometry-btn');
        const geminiOutputDiv = document.getElementById('gemini-output');
        const loader = document.getElementById('loader');

        // State
        let scale = 50;
        let origin = { x: 0, y: 0 };
        let activeTab = 'root-form';
        let equationParams = {};
        let solutions_z = [];

        function parseComplexInput(str) {
            str = str.trim().toLowerCase().replace(/\s/g, '');
            if (!str) return { real: 0, imag: 0 };
            if (str === 'i') return { real: 0, imag: 1 };
            if (str === '-i') return { real: 0, imag: -1 };
    
            // Regex to handle various complex number formats
            const match = str.match(/^(-?\d*\.?\d+)?([+-]\d*\.?\d*)?i?$/);
            if (!match) return { real: parseFloat(str) || 0, imag: 0 }; // Fallback for simple numbers
            
            let real = 0;
            let imag = 0;
    
            const hasI = str.includes('i');
    
            if (hasI) {
                const parts = str.split(/[+-](?=\d|i)/);
                let firstPartIsNegative = false;
                if (str.startsWith('-')) {
                    firstPartIsNegative = true;
                    if (parts[0] === '') parts.shift();
                    parts[0] = '-' + parts[0];
                }

                for (let part of parts) {
                    if (part.endsWith('i')) {
                        let imagStr = part.slice(0, -1);
                        if (imagStr === '' || imagStr === '+') imag += 1;
                        else if (imagStr === '-') imag += -1;
                        else imag += parseFloat(imagStr) || 0;
                    } else {
                        real += parseFloat(part) || 0;
                    }
                }
            } else {
                real = parseFloat(str) || 0;
            }
            return { real, imag };
        }

        // --- Complex Number Arithmetic ---
        const ComplexOps = {
            add: (z1, z2) => ({ real: z1.real + z2.real, imag: z1.imag + z2.imag }),
            subtract: (z1, z2) => ({ real: z1.real - z2.real, imag: z1.imag - z2.imag }),
            multiply: (z1, z2) => ({
                real: z1.real * z2.real - z1.imag * z2.imag,
                imag: z1.real * z2.imag + z1.imag * z2.real
            }),
            divide: (z1, z2) => {
                const den = z2.real**2 + z2.imag**2;
                if (den === 0) return { real: Infinity, imag: Infinity };
                return {
                    real: (z1.real * z2.real + z1.imag * z2.imag) / den,
                    imag: (z1.imag * z2.real - z1.real * z2.imag) / den
                };
            }
        };

        // --- Equation Solving ---
        function solveRootForm() {
            equationParams = {
                c: { real: parseFloat(cRealInput.value) || 0, imag: parseFloat(cImagInput.value) || 0 },
                n: parseInt(nPowerInput.value) || 4,
                w: { real: parseFloat(wRealInput.value) || 0, imag: parseFloat(wImagInput.value) || 0 },
            };
            const { c, n, w } = equationParams;
            const r = Math.sqrt(w.real**2 + w.imag**2);
            const theta = Math.atan2(w.imag, w.real);
            const radius = Math.pow(r, 1 / n);

            solutions_z = [];
            for (let k = 0; k < n; k++) {
                const angle = (theta + 2 * k * Math.PI) / n;
                const wk = { real: radius * Math.cos(angle), imag: radius * Math.sin(angle) };
                solutions_z.push({ real: wk.real + c.real, imag: wk.imag + c.imag, name: `z${k}` });
            }
            updateInfoPanel();
        }

        function solvePolyForm() {
            const coeffs = [
                parseComplexInput(polyInputs.e.value), parseComplexInput(polyInputs.d.value),
                parseComplexInput(polyInputs.c.value), parseComplexInput(polyInputs.b.value),
                parseComplexInput(polyInputs.a.value)
            ];

            if(coeffs[4].real === 0 && coeffs[4].imag === 0) {
                coeffs[4] = { real: 1, imag: 0 };
                polyInputs.a.value = "1";
            }
            
            equationParams = { coeffs: coeffs.slice().reverse() }; 
            
            const degree = coeffs.length - 1;
            let roots = [];
            for (let i = 0; i < degree; i++) {
                const angle = 2 * Math.PI * i / degree;
                const radius = 0.9 + Math.random() * 0.2; 
                roots.push({ real: radius * Math.cos(angle), imag: radius * Math.sin(angle) });
            }
            
            const polyval_correct = (p, z) => {
                 let r = {real: 0, imag: 0};
                 for(let i=p.length-1; i>=0; i--) {
                     r = ComplexOps.add(ComplexOps.multiply(r, z), p[i]);
                 }
                 return r;
            }

            for (let iter = 0; iter < 150; iter++) {
                const next_roots = [...roots];
                let all_converged = true;
                for (let i = 0; i < degree; i++) {
                    let p = roots[i];
                    let numerator = polyval_correct(coeffs, p);
                    let denominator = {real: 1, imag: 0};
                    for (let j = 0; j < degree; j++) {
                        if (i !== j) {
                            denominator = ComplexOps.multiply(denominator, ComplexOps.subtract(p, roots[j]));
                        }
                    }
                    if(Math.abs(denominator.real) < 1e-12 && Math.abs(denominator.imag) < 1e-12) continue;
                    const correction = ComplexOps.divide(numerator, denominator);
                    next_roots[i] = ComplexOps.subtract(p, correction);
                    
                    if (Math.sqrt(correction.real**2 + correction.imag**2) > 1e-7) {
                        all_converged = false;
                    }
                }
                roots = next_roots;
                if(all_converged) break;
            }
            
            solutions_z = roots.map((r, index) => ({ real: r.real, imag: r.imag, name: `z${index}` }));
            updateInfoPanel();
        }

        function updateAndSolve() {
            geminiOutputDiv.classList.add('hidden');
            if (activeTab === 'root-form') {
                solveRootForm();
            } else {
                solvePolyForm();
            }
            draw();
        }

        function updateInfoPanel() {
            if (activeTab === 'root-form') {
                 const { c, n, w } = equationParams;
                 const radius = Math.pow(Math.sqrt(w.real**2 + w.imag**2), 1/n);
                 let solutionHTML = `<p class="font-semibold text-indigo-700">Các đỉnh (nghiệm):</p>`;
                 solutions_z.forEach(z => {
                    solutionHTML += `<p class="text-gray-700 font-mono text-xs">${z.name} ≈ ${z.real.toFixed(3)} + ${z.imag.toFixed(3)}i</p>`;
                 });
                 infoPanel.innerHTML = `
                    <div><p class="font-semibold text-indigo-700">Hình dạng:</p><p class="text-gray-700">${n}-giác đều</p></div>
                    <div><p class="font-semibold text-indigo-700">Tâm đa giác:</p><p class="text-gray-700">c = ${c.real} + ${c.imag}i</p></div>
                    <div><p class="font-semibold text-indigo-700">Bán kính ngoại tiếp:</p><p class="text-gray-700">R ≈ ${radius.toFixed(3)}</p></div>
                    <div id="solution-list">${solutionHTML}</div>`;
            } else { // poly-form
                 let solutionHTML = `<p class="font-semibold text-indigo-700">Các nghiệm tìm được:</p>`;
                 solutions_z.forEach(z => {
                    solutionHTML += `<p class="text-gray-700 font-mono text-xs">${z.name} ≈ ${z.real.toFixed(3)} + ${z.imag.toFixed(3)}i</p>`;
                 });
                 infoPanel.innerHTML = `<div id="solution-list">${solutionHTML}</div>`;
            }
        }

        function drawSolutions() {
            if (solutions_z.length === 0) return;
            
            if (activeTab === 'root-form' && solutions_z.length > 1) {
                const { c } = equationParams;
                const center = { real: c.real, imag: c.imag };
                const canvasCenter = toCanvasCoords(center.real, center.imag);
                const radius = Math.sqrt((solutions_z[0].real - center.real)**2 + (solutions_z[0].imag - center.imag)**2);

                ctx.strokeStyle = 'rgba(129, 140, 248, 0.5)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(canvasCenter.x, canvasCenter.y, radius * scale, 0, 2 * Math.PI); ctx.stroke();

                ctx.strokeStyle = '#4f46e5'; ctx.lineWidth = 2.5;
                ctx.beginPath();
                const firstPoint = toCanvasCoords(solutions_z[0].real, solutions_z[0].imag);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < solutions_z.length; i++) {
                    ctx.lineTo(toCanvasCoords(solutions_z[i].real, solutions_z[i].imag).x, toCanvasCoords(solutions_z[i].real, solutions_z[i].imag).y);
                }
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(canvasCenter.x, canvasCenter.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.fillStyle = '#7f1d1d'; ctx.fillText('c', canvasCenter.x + 10, canvasCenter.y - 10);
            } else if (activeTab === 'poly-form' && solutions_z.length > 1) {
                ctx.strokeStyle = '#16a34a'; 
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); 
                ctx.beginPath();
                const firstPoint = toCanvasCoords(solutions_z[0].real, solutions_z[0].imag);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < solutions_z.length; i++) {
                    const point = toCanvasCoords(solutions_z[i].real, solutions_z[i].imag);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]); 
            }


            // Draw points for all forms
            solutions_z.forEach(z => {
                const pos = toCanvasCoords(z.real, z.imag);
                ctx.fillStyle = '#4f46e5';
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.fillStyle = '#312e81'; ctx.font = '14px Inter';
                ctx.fillText(z.name, pos.x + 10, pos.y - 10);
            });
        }
        
        // --- Canvas Drawing --- (resize, toCanvas, grid, axes, draw main)
        function resizeCanvas() {
            if (!canvas.parentElement) return;
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            origin.x = canvas.width / 2;
            origin.y = canvas.height / 2;
            scale = Math.min(canvas.width, canvas.height) / 8;
            draw();
        }
        function toCanvasCoords(real, imag) {
            return { x: origin.x + real * scale, y: origin.y - imag * scale };
        }
        function drawGrid() {
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.font = '10px Inter'; ctx.fillStyle = '#64748b';
            for (let i = -20; i <= 20; i++) {
                if (i === 0) continue;
                const pos_x = toCanvasCoords(i, 0);
                if(pos_x.x > 0 && pos_x.x < canvas.width) {
                    ctx.beginPath(); ctx.moveTo(pos_x.x, 0); ctx.lineTo(pos_x.x, canvas.height); ctx.stroke();
                    ctx.fillText(i, pos_x.x + 2, origin.y - 2);
                }
                const pos_y = toCanvasCoords(0, i);
                 if(pos_y.y > 0 && pos_y.y < canvas.height) {
                    ctx.beginPath(); ctx.moveTo(0, pos_y.y); ctx.lineTo(canvas.width, pos_y.y); ctx.stroke();
                    ctx.fillText(i + 'i', origin.x + 2, pos_y.y - 2);
                }
            }
        }
        function drawAxes() {
            ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height); ctx.stroke();
            ctx.fillStyle = "#1e293b"; ctx.font = '14px Inter';
            ctx.fillText('Re', canvas.width - 25, origin.y - 10);
            ctx.fillText('Im', origin.x + 10, 15);
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawSolutions();
        }

        // --- Gemini API Integration ---
        const apiKey = "AIzaSyDn0PSVG4ULFCG-mqRWjSARF1rSso5BktQ";
        async function callGemini(prompt) {
            loader.classList.remove('hidden'); geminiOutputDiv.classList.add('hidden'); geminiOutputDiv.textContent = '';
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            let response; let retries = 0; const maxRetries = 5; let delay = 1000;
            while (retries < maxRetries) {
                try {
                    response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (response.ok) break; else if (response.status === 429) { await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; retries++; } else { throw new Error(`API error: ${response.statusText}`); }
                } catch (error) { console.error("Fetch error:", error); retries++; await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; }
            }
            loader.classList.add('hidden'); geminiOutputDiv.classList.remove('hidden');
            if (!response || !response.ok) { geminiOutputDiv.textContent = 'Đã có lỗi xảy ra khi gọi Gemini API.'; return; }
            try {
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const formattedText = candidate.content.parts[0].text.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\* (.*?)(<br>|$)/g, '<li class="ml-4 list-disc">$1</li>');
                    geminiOutputDiv.innerHTML = `<ul>${formattedText}</ul>`;
                } else { geminiOutputDiv.textContent = 'Không nhận được nội dung hợp lệ từ Gemini.'; }
            } catch (error) { console.error('Error parsing response:', error); geminiOutputDiv.textContent = 'Lỗi xử lý phản hồi từ Gemini.'; }
        }

       function generatePrompt(type) {
            if (solutions_z.length === 0) return "Hãy giải thích chung về mặt phẳng phức.";
            const example_z = solutions_z[0];
            const example_str = `${example_z.real.toFixed(2)} + ${example_z.imag.toFixed(2)}i`;

            if (type === 'plot') {
                return `Giải thích cách biểu diễn các nghiệm phức trên mặt phẳng tọa độ. Một số phức z = a + bi tương ứng với điểm nào? Trục hoành (Re) và trục tung (Im) đại diện cho cái gì? Cho ví dụ với nghiệm ${example_z.name} ≈ ${example_str}, nó sẽ được đặt ở điểm nào trên hệ tọa độ?`;
            }

            if (type === 'geometry') {
                if (activeTab === 'root-form') {
                    const { n, c } = equationParams;
                    const c_str = `${c.real} ${c.imag >= 0 ? '+' : '-'} ${Math.abs(c.imag)}i`;
                    return `Giải thích ý nghĩa hình học của các nghiệm. Tại sao chúng lại tạo thành một ${n}-giác đều? Tâm của đa giác đó là (${c_str}) có ý nghĩa gì? Bán kính của đường tròn ngoại tiếp đa giác là gì và được tính như thế nào?`;
                } else { // poly-form
                     const complexCoeffs = equationParams.coeffs;
                     let poly_str = complexCoeffs.map((c, i) => {
                        if (c.real === 0 && c.imag === 0) return '';
                        let term = '';
                        if (c.real !== 0 && c.imag !== 0) term = `(${c.real}${c.imag > 0 ? '+' : ''}${c.imag}i)`;
                        else if (c.real !== 0) term = `${c.real}`;
                        else term = c.imag === 1 ? 'i' : (c.imag === -1 ? '-i' : `${c.imag}i`);
                        const power = complexCoeffs.length - 1 - i;
                        if (power > 0) term += `z^${power > 1 ? power : ''}`;
                        return term;
                    }).filter(t => t).join(' + ').replace(/\+ -/g, '- ');

                    const allReal = complexCoeffs.every(c => c.imag === 0);
                    let promptText = `Phân tích các nghiệm của đa thức P(z) = ${poly_str} = 0. `;
                    if (allReal) {
                        promptText += "Vì các hệ số là số thực, các nghiệm phức có tính chất đối xứng gì qua trục thực không? Hãy giải thích.";
                    } else {
                        promptText += "Vì đa thức có hệ số phức, các nghiệm có thể không đối xứng qua trục thực. Hãy giải thích chung về vị trí của các nghiệm này.";
                    }
                    return promptText;
                }
            }
        }
        
        // --- Event Listeners and Initial Setup ---
        function handleDownload() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'complex_plane_explorer.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                activeTab = tab.dataset.tab;
                tabContents.forEach(c => c.classList.remove('active'));
                document.getElementById(activeTab).classList.add('active');
                updateAndSolve();
            });
        });
        
        downloadBtn.addEventListener('click', handleDownload);
        explainPlotBtn.addEventListener('click', () => callGemini(generatePrompt('plot')));
        explainGeometryBtn.addEventListener('click', () => callGemini(generatePrompt('geometry')));
        window.addEventListener('resize', resizeCanvas);
        redrawBtn.addEventListener('click', updateAndSolve);
        
        // Set initial value for sqrt(3) & First draw
        wImagInput.value = Math.sqrt(3).toFixed(3);
        resizeCanvas();
        updateAndSolve();
    </script>
</body>
</html>

