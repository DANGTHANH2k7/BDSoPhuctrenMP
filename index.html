<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khám phá Nghiệm Phức</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #f8fafc;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .tab-btn {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-btn.active {
            border-bottom-color: #4f46e5;
            color: #4f46e5;
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center h-screen">
    <div class="w-full h-full p-4 flex flex-col md:flex-row gap-4">
        <div class="flex-grow bg-white rounded-xl shadow-lg overflow-hidden">
            <canvas id="complexPlane"></canvas>
        </div>
        <div class="w-full md:w-96 bg-white rounded-xl shadow-lg p-6 flex-shrink-0 flex flex-col">
            <h1 class="text-xl font-bold text-gray-800 border-b pb-3 mb-4">Bảng điều khiển</h1>
            
            <!-- Tabs -->
            <div class="flex border-b mb-4">
                <button class="tab-btn active" data-tab="root-form">Dạng Căn</button>
                <button class="tab-btn" data-tab="poly-form">Dạng Đa thức</button>
            </div>

            <!-- Equation Input Section -->
            <div id="root-form" class="tab-content active space-y-4 text-sm mb-4">
                <p class="font-semibold text-gray-700">Phương trình: (z - c)ⁿ = w</p>
                <div class="flex items-center gap-2">
                    <span class="font-mono text-lg">(z - (</span>
                    <input type="number" id="c_real" value="0" class="w-12 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">+</span>
                    <input type="number" id="c_imag" value="1" class="w-12 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">i))</span>
                    <span class="font-mono text-lg relative bottom-2">^</span>
                    <input type="number" id="n_power" value="4" min="2" max="20" class="w-12 text-center border rounded-md p-1 font-mono">
                </div>
                <div class="flex items-center gap-2">
                    <span class="font-mono text-lg">=</span>
                    <input type="number" id="w_real" value="1" class="w-16 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">+</span>
                    <input type="number" id="w_imag" value="1.732" step="0.001" class="w-16 text-center border rounded-md p-1 font-mono">
                    <span class="font-mono text-lg">i</span>
                </div>
            </div>
            <div id="poly-form" class="tab-content space-y-2 text-sm mb-4">
                 <p class="font-semibold text-gray-700">Phương trình: az⁴+bz³+cz²+dz+e = 0</p>
                 <div class="grid grid-cols-2 gap-2 items-center">
                    <label class="font-mono" for="poly_a">a (z⁴):</label><input type="number" id="poly_a" value="1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_b">b (z³):</label><input type="number" id="poly_b" value="-1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_c">c (z²):</label><input type="number" id="poly_c" value="1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_d">d (z):</label><input type="number" id="poly_d" value="-1" class="border rounded-md p-1 font-mono">
                    <label class="font-mono" for="poly_e">e:</label><input type="number" id="poly_e" value="1" class="border rounded-md p-1 font-mono">
                 </div>
            </div>

            <button id="redraw-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors mb-4">
                Giải & Vẽ
            </button>

             <!-- Info Display Section -->
            <div id="info-panel" class="space-y-3 text-sm border-t pt-4">
                 <!-- Info will be populated by JS -->
            </div>

            <!-- Gemini Features Section -->
            <div class="mt-auto pt-4 border-t">
                <h2 class="text-lg font-bold text-gray-800 mb-3">✨ Trợ lý Gemini</h2>
                <div class="space-y-2">
                    <button id="explain-plot-btn" class="w-full text-left bg-indigo-100 hover:bg-indigo-200 text-indigo-800 font-semibold py-2 px-4 rounded-lg transition-colors">
                        Cách biểu diễn nghiệm
                    </button>
                    <button id="explain-geometry-btn" class="w-full text-left bg-indigo-100 hover:bg-indigo-200 text-indigo-800 font-semibold py-2 px-4 rounded-lg transition-colors">
                        Giải thích ý nghĩa hình học
                    </button>
                </div>
                <div id="loader" class="hidden">
                    <div class="loader"></div>
                </div>
                <div id="gemini-output" class="mt-4 p-3 bg-slate-50 rounded-lg text-sm text-gray-700 max-h-40 overflow-y-auto hidden">
                    <!-- Gemini response will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel');
        const redrawBtn = document.getElementById('redraw-btn');
        const tabs = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Input fields
        const cRealInput = document.getElementById('c_real');
        const cImagInput = document.getElementById('c_imag');
        const nPowerInput = document.getElementById('n_power');
        const wRealInput = document.getElementById('w_real');
        const wImagInput = document.getElementById('w_imag');
        const polyInputs = {
            a: document.getElementById('poly_a'), b: document.getElementById('poly_b'),
            c: document.getElementById('poly_c'), d: document.getElementById('poly_d'),
            e: document.getElementById('poly_e')
        };

        // Gemini elements
        const explainPlotBtn = document.getElementById('explain-plot-btn');
        const explainGeometryBtn = document.getElementById('explain-geometry-btn');
        const geminiOutputDiv = document.getElementById('gemini-output');
        const loader = document.getElementById('loader');

        // State
        let scale = 50;
        let origin = { x: 0, y: 0 };
        let activeTab = 'root-form';
        let equationParams = {};
        let solutions_z = [];

        // --- Complex Number Arithmetic ---
        const ComplexOps = {
            add: (z1, z2) => ({ real: z1.real + z2.real, imag: z1.imag + z2.imag }),
            subtract: (z1, z2) => ({ real: z1.real - z2.real, imag: z1.imag - z2.imag }),
            multiply: (z1, z2) => ({
                real: z1.real * z2.real - z1.imag * z2.imag,
                imag: z1.real * z2.imag + z1.imag * z2.real
            }),
            divide: (z1, z2) => {
                const den = z2.real**2 + z2.imag**2;
                if (den === 0) return { real: Infinity, imag: Infinity };
                return {
                    real: (z1.real * z2.real + z1.imag * z2.imag) / den,
                    imag: (z1.imag * z2.real - z1.real * z2.imag) / den
                };
            }
        };

        // --- Equation Solving ---
        function solveRootForm() {
            equationParams = {
                c: { real: parseFloat(cRealInput.value) || 0, imag: parseFloat(cImagInput.value) || 0 },
                n: parseInt(nPowerInput.value) || 4,
                w: { real: parseFloat(wRealInput.value) || 0, imag: parseFloat(wImagInput.value) || 0 },
            };
            const { c, n, w } = equationParams;
            const r = Math.sqrt(w.real**2 + w.imag**2);
            const theta = Math.atan2(w.imag, w.real);
            const radius = Math.pow(r, 1 / n);

            solutions_z = [];
            for (let k = 0; k < n; k++) {
                const angle = (theta + 2 * k * Math.PI) / n;
                const wk = { real: radius * Math.cos(angle), imag: radius * Math.sin(angle) };
                solutions_z.push({ real: wk.real + c.real, imag: wk.imag + c.imag, name: `z${k}` });
            }
            updateInfoPanel();
        }

        function solvePolyForm() {
            const coeffs = [
                parseFloat(polyInputs.e.value) || 0, parseFloat(polyInputs.d.value) || 0,
                parseFloat(polyInputs.c.value) || 0, parseFloat(polyInputs.b.value) || 0,
                parseFloat(polyInputs.a.value) || 1
            ].map(c => ({real: c, imag: 0}));

            equationParams = { coeffs: coeffs.map(c => c.real).reverse() }; // For prompt
            
            // Durand-Kerner method for finding polynomial roots
            const degree = coeffs.length - 1;
            let roots = [];
            // FIX: Perturb initial guesses to improve numerical stability
            for (let i = 0; i < degree; i++) {
                const angle = 2 * Math.PI * i / degree;
                const radius = 0.9 + Math.random() * 0.2; // Slightly randomized radius near 1
                roots.push({ real: radius * Math.cos(angle), imag: radius * Math.sin(angle) });
            }
            
            const polyval_correct = (p, z) => {
                 let r = {real: 0, imag: 0};
                 for(let i=p.length-1; i>=0; i--) {
                     r = ComplexOps.add(ComplexOps.multiply(r, z), p[i]);
                 }
                 return r;
            }

            for (let iter = 0; iter < 150; iter++) { // Increased iterations for stability
                const next_roots = [...roots];
                let all_converged = true;
                for (let i = 0; i < degree; i++) {
                    let p = roots[i];
                    let numerator = polyval_correct(coeffs, p);
                    let denominator = {real: 1, imag: 0};
                    for (let j = 0; j < degree; j++) {
                        if (i !== j) {
                            denominator = ComplexOps.multiply(denominator, ComplexOps.subtract(p, roots[j]));
                        }
                    }
                    if(Math.abs(denominator.real) < 1e-12 && Math.abs(denominator.imag) < 1e-12) continue;
                    const correction = ComplexOps.divide(numerator, denominator);
                    next_roots[i] = ComplexOps.subtract(p, correction);
                    
                    if (Math.sqrt(correction.real**2 + correction.imag**2) > 1e-7) {
                        all_converged = false;
                    }
                }
                roots = next_roots;
                if(all_converged) break;
            }
            
            solutions_z = roots.map((r, index) => ({ real: r.real, imag: r.imag, name: `z${index}` }));
            updateInfoPanel();
        }

        function updateAndSolve() {
            geminiOutputDiv.classList.add('hidden');
            if (activeTab === 'root-form') {
                solveRootForm();
            } else {
                solvePolyForm();
            }
            draw();
        }

        function updateInfoPanel() {
            if (activeTab === 'root-form') {
                 const { c, n, w } = equationParams;
                 const radius = Math.pow(Math.sqrt(w.real**2 + w.imag**2), 1/n);
                 let solutionHTML = `<p class="font-semibold text-indigo-700">Các đỉnh (nghiệm):</p>`;
                 solutions_z.forEach(z => {
                    solutionHTML += `<p class="text-gray-700 font-mono text-xs">${z.name} ≈ ${z.real.toFixed(3)} + ${z.imag.toFixed(3)}i</p>`;
                 });
                 infoPanel.innerHTML = `
                    <div><p class="font-semibold text-indigo-700">Hình dạng:</p><p class="text-gray-700">${n}-giác đều</p></div>
                    <div><p class="font-semibold text-indigo-700">Tâm đa giác:</p><p class="text-gray-700">c = ${c.real} + ${c.imag}i</p></div>
                    <div><p class="font-semibold text-indigo-700">Bán kính ngoại tiếp:</p><p class="text-gray-700">R ≈ ${radius.toFixed(3)}</p></div>
                    <div id="solution-list">${solutionHTML}</div>`;
            } else { // poly-form
                 let solutionHTML = `<p class="font-semibold text-indigo-700">Các nghiệm tìm được:</p>`;
                 solutions_z.forEach(z => {
                    solutionHTML += `<p class="text-gray-700 font-mono text-xs">${z.name} ≈ ${z.real.toFixed(3)} + ${z.imag.toFixed(3)}i</p>`;
                 });
                 infoPanel.innerHTML = `<div id="solution-list">${solutionHTML}</div>`;
            }
        }

        function drawSolutions() {
            if (solutions_z.length === 0) return;
            
            if (activeTab === 'root-form' && solutions_z.length > 1) {
                const { c } = equationParams;
                const center = { real: c.real, imag: c.imag };
                const canvasCenter = toCanvasCoords(center.real, center.imag);
                const radius = Math.sqrt((solutions_z[0].real - center.real)**2 + (solutions_z[0].imag - center.imag)**2);

                ctx.strokeStyle = 'rgba(129, 140, 248, 0.5)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(canvasCenter.x, canvasCenter.y, radius * scale, 0, 2 * Math.PI); ctx.stroke();

                ctx.strokeStyle = '#4f46e5'; ctx.lineWidth = 2.5;
                ctx.beginPath();
                const firstPoint = toCanvasCoords(solutions_z[0].real, solutions_z[0].imag);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < solutions_z.length; i++) {
                    ctx.lineTo(toCanvasCoords(solutions_z[i].real, solutions_z[i].imag).x, toCanvasCoords(solutions_z[i].real, solutions_z[i].imag).y);
                }
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(canvasCenter.x, canvasCenter.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.fillStyle = '#7f1d1d'; ctx.fillText('c', canvasCenter.x + 10, canvasCenter.y - 10);
            } else if (activeTab === 'poly-form' && solutions_z.length > 1) {
                // FIX: Add drawing for polygon shape
                ctx.strokeStyle = '#16a34a'; // A distinct green color
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dashed line style
                ctx.beginPath();
                const firstPoint = toCanvasCoords(solutions_z[0].real, solutions_z[0].imag);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < solutions_z.length; i++) {
                    const point = toCanvasCoords(solutions_z[i].real, solutions_z[i].imag);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
            }


            // Draw points for all forms
            solutions_z.forEach(z => {
                const pos = toCanvasCoords(z.real, z.imag);
                ctx.fillStyle = '#4f46e5';
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.fillStyle = '#312e81'; ctx.font = '14px Inter';
                ctx.fillText(z.name, pos.x + 10, pos.y - 10);
            });
        }
        
        // --- Canvas Drawing --- (resize, toCanvas, grid, axes, draw main)
        function resizeCanvas() {
            if (!canvas.parentElement) return;
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            origin.x = canvas.width / 2;
            origin.y = canvas.height / 2;
            scale = Math.min(canvas.width, canvas.height) / 8;
            draw();
        }
        function toCanvasCoords(real, imag) {
            return { x: origin.x + real * scale, y: origin.y - imag * scale };
        }
        function drawGrid() {
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.font = '10px Inter'; ctx.fillStyle = '#64748b';
            for (let i = -20; i <= 20; i++) {
                if (i === 0) continue;
                const pos_x = toCanvasCoords(i, 0);
                if(pos_x.x > 0 && pos_x.x < canvas.width) {
                    ctx.beginPath(); ctx.moveTo(pos_x.x, 0); ctx.lineTo(pos_x.x, canvas.height); ctx.stroke();
                    ctx.fillText(i, pos_x.x + 2, origin.y - 2);
                }
                const pos_y = toCanvasCoords(0, i);
                 if(pos_y.y > 0 && pos_y.y < canvas.height) {
                    ctx.beginPath(); ctx.moveTo(0, pos_y.y); ctx.lineTo(canvas.width, pos_y.y); ctx.stroke();
                    ctx.fillText(i + 'i', origin.x + 2, pos_y.y - 2);
                }
            }
        }
        function drawAxes() {
            ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height); ctx.stroke();
            ctx.fillStyle = "#1e293b"; ctx.font = '14px Inter';
            ctx.fillText('Re', canvas.width - 25, origin.y - 10);
            ctx.fillText('Im', origin.x + 10, 15);
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawSolutions();
        }

        // --- Gemini API Integration ---
        const apiKey = "AIzaSyDn0PSVG4ULFCG-mqRWjSARF1rSso5BktQ";
        async function callGemini(prompt) {
            loader.classList.remove('hidden'); geminiOutputDiv.classList.add('hidden'); geminiOutputDiv.textContent = '';
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            let response; let retries = 0; const maxRetries = 5; let delay = 1000;
            while (retries < maxRetries) {
                try {
                    response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (response.ok) break; else if (response.status === 429) { await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; retries++; } else { throw new Error(`API error: ${response.statusText}`); }
                } catch (error) { console.error("Fetch error:", error); retries++; await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; }
            }
            loader.classList.add('hidden'); geminiOutputDiv.classList.remove('hidden');
            if (!response || !response.ok) { geminiOutputDiv.textContent = 'Đã có lỗi xảy ra khi gọi Gemini API.'; return; }
            try {
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const formattedText = candidate.content.parts[0].text.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\* (.*?)(<br>|$)/g, '<li class="ml-4 list-disc">$1</li>');
                    geminiOutputDiv.innerHTML = `<ul>${formattedText}</ul>`;
                } else { geminiOutputDiv.textContent = 'Không nhận được nội dung hợp lệ từ Gemini.'; }
            } catch (error) { console.error('Error parsing response:', error); geminiOutputDiv.textContent = 'Lỗi xử lý phản hồi từ Gemini.'; }
        }

        function generatePrompt(type) {
            if (solutions_z.length === 0) return "Hãy giải thích chung về mặt phẳng phức.";
            const example_z = solutions_z[0];
            const example_str = `${example_z.real.toFixed(2)} + ${example_z.imag.toFixed(2)}i`;
            const point_str = `(${example_z.real.toFixed(2)}, ${example_z.imag.toFixed(2)})`;

            if (type === 'plot') {
                return `Giải thích cách biểu diễn các nghiệm phức trên mặt phẳng tọa độ. Một số phức z = a + bi tương ứng với điểm nào? Trục hoành (Re) và trục tung (Im) đại diện cho cái gì? Cho ví dụ với nghiệm ${example_z.name} ≈ ${example_str}, nó sẽ được đặt ở điểm nào trên hệ tọa độ?`;
            }

            if (type === 'geometry') {
                if (activeTab === 'root-form') {
                    const { n, c } = equationParams;
                    const c_str = `${c.real} ${c.imag >= 0 ? '+' : '-'} ${Math.abs(c.imag)}i`;
                    return `Giải thích ý nghĩa hình học của các nghiệm. Tại sao chúng lại tạo thành một ${n}-giác đều? Tâm của đa giác đó là (${c_str}) có ý nghĩa gì? Bán kính của đường tròn ngoại tiếp đa giác là gì và được tính như thế nào?`;
                } else { // poly-form
                    const { coeffs } = equationParams;
                    let poly_str = coeffs.map((c, i) => `${c}z^${coeffs.length - 1 - i}`).join(' + ').replace(/\+ -/g, '- ');
                    return `Phân tích các nghiệm của đa thức P(z) = ${poly_str} = 0. Vì các hệ số là số thực, các nghiệm phức có tính chất đối xứng gì qua trục thực không? Hãy giải thích.`;
                }
            }
        }
        
        // --- Event Listeners and Initial Setup ---
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                activeTab = tab.dataset.tab;
                tabContents.forEach(c => c.classList.remove('active'));
                document.getElementById(activeTab).classList.add('active');
                updateAndSolve();
            });
        });
        
        explainPlotBtn.addEventListener('click', () => callGemini(generatePrompt('plot')));
        explainGeometryBtn.addEventListener('click', () => callGemini(generatePrompt('geometry')));
        window.addEventListener('resize', resizeCanvas);
        redrawBtn.addEventListener('click', updateAndSolve);
        
        // Set initial value for sqrt(3) & First draw
        wImagInput.value = Math.sqrt(3).toFixed(3);
        resizeCanvas();
        updateAndSolve();
    </script>
</body>
</html>

